import pgzrun
import types
##Initialize
WIDTH,HEIGHT = 768,432
TIME = 0
runlset,runrset,idlelset,idlerset = [],[],[],[] #List of actions' frames
bg = [] #Background
floor = [] #Floor
block = [] #Block
star = []
countstar = []
spdx = 3 #Speed of moves
door = Actor('door')
starsum = 0
stage = 1

##Import images
#Character
for i in range(8):
    runrset.append('run\\runr\\right'+str(i))
    runlset.append('run\\runl\\left'+str(i))
for i in range(12):
    idlerset.append('idle\\idler\\idler'+str(i))
    idlelset.append('idle\\idlel\\idlel'+str(i))
#Background
for i in range(5):
    bg.append(Actor("background\\plx-" + str(i+1)))
#Floor(stage1)
for i in range(2):
    floor.append(Actor('tileset\\ground'))
#Block(stage2)
for i in range(10):
    block.append(Actor('tileset\\block'))
#Star
for i in range(3):
    star.append(Actor('star'))
#Countstar
for i in range(3):
    countstar.append(Actor('greystar'))



##Setup Character
PLAYER = Actor('idle\idler\idler0')
PLAYER.jumph = 0
PLAYER.frame = 0
PLAYER.state = 'IDLE'
PLAYER.direction = 'RIGHT'

##initialize Variable
def initializeVariable():
    global PLAYER, starsum, star, countstar
    PLAYER.jumph = 0
    PLAYER.frame = 0
    PLAYER.state = 'IDLE'
    PLAYER.direction = 'RIGHT'
    starsum = 0
    star = []
    for i in range(3):
        star.append(Actor('star'))
    countstar = []
    for i in range(3):
        countstar.append(Actor('greystar'))



##Setup map
def initializeMap():
    #Background
    for i in range(5):
        bg[i].topleft = 0,0
    #Floor
    floor[0].bottomright = WIDTH * 0.5, HEIGHT - PLAYER.height - floor[0].height + 2
    floor[1].bottomleft = WIDTH * 0.5, HEIGHT - PLAYER.height - floor[0].height + 2
    #Door
    door.bottomright = floor[1].right, floor[1].top + 5
    # Player
    PLAYER.bottomleft = floor[0].topleft
    #Star
    for i in range(3):
        star[i].bottomleft = floor[0].left + PLAYER.width + (i + 1) * 60, floor[0].top - 10
    #Countstar
    for i in range(3):
        countstar[i].midtop = WIDTH * 0.5 + (i - 1) * 60, 30

def initializeMap2():
    # Background
    for i in range(5):
        bg[i].topleft = 0, 0
    #Block
    block[0].midbottom = WIDTH * 0.5 - 26, HEIGHT - 30
    block[1].midbottom = WIDTH * 0.5 + 26, HEIGHT - 30
    block[2].bottomright = block[0].topleft
    block[3].bottomleft = block[1].topright
    block[4].bottomleft = block[3].bottomright
    block[5].bottomright = block[2].topleft
    block[6].bottomright = block[3].topright
    block[7].bottomright = block[5].topright
    block[8].bottomleft = block[2].right, block[7].bottom
    block[9].bottomright = block[6].topleft
    #Door
    door.bottomright = block[4].topright
    #Player
    PLAYER.bottomleft = block[0].topleft
    # Star
    star[0].midbottom = block[1].midtop
    star[1].midbottom = block[2].midtop
    star[2].midbottom = block[9].midtop
    # Countstar
    for i in range(3):
        countstar[i].midtop = WIDTH * 0.5 + (i - 1) * 60, 30


##Restart the game
def StageRestart():
    initializeVariable()
    initializeMap()

def SecondStage():
    initializeVariable()
    initializeMap2()



##Actor Moves
#Infinite Moves
def moveLeft(act,mode=0): ##Mode 0: Infinite Move; Mode 1: Bordered Move
    if(mode == 1 and act.left <= 0):
        return
    act.left -= spdx
    if(mode == 0 and act.right < 0):
        act.left = WIDTH-spdx

def moveRight(act,mode=0):
    if(mode == 1 and act.right >= WIDTH):
        return
    act.left += spdx
    if(mode == 0 and act.left > WIDTH):
        act.right = spdx

allfloor = block + floor
#Collision
def collideFloor():
    for i in allfloor:
        if(PLAYER.colliderect(i) and i.top-4*spdx<= PLAYER.bottom <= i.top+4*spdx):
            return True
    return False


## Set Attribute
PLAYER.__setattr__('moveRight',types.MethodType(moveRight,PLAYER))
PLAYER.__setattr__('moveLeft',types.MethodType(moveLeft,PLAYER))


# Player lose and win:
def playerlose():
    global PLAYER, starsum
    if starsum < 3 and PLAYER.collidepoint(door.center):
        return True
    elif PLAYER.top >= HEIGHT:
        return True
    return False

def playerwin():
    global PLAYER, starsum
    if starsum == 3 and PLAYER.collidepoint(door.center):
        return True
    else:
        return False

def drawStage():
    for i in bg:
        i.draw()
    for i in countstar:
        i.draw()
    for i in star:
        i.draw()
    if stage == 1:
        for i in floor:
            i.draw()
    elif stage == 2:
        for i in block:
            i.draw()



##Draw & Update
def draw():
    screen.clear()
    drawStage()
    door.draw()
    PLAYER.draw()




def update():
    global PLAYER, starsum, stage
    PLAYER.floor = collideFloor()
    if PLAYER.state == 'DEAD':
        return
    ##win or lose
    if playerlose():
        PLAYER.state = 'DEAD'
        clock.schedule(StageRestart, 3.0)
        return
    if playerwin():
        stage += 1
        clock.schedule(SecondStage, 3.0)
        return
    ##Pick Star
    for i in star:
        if PLAYER.colliderect(i):
            star.remove(i)
            starsum += 1
            countstar[starsum - 1].image = 'brightstar'
    ##JUMP
    if(keyboard.up and PLAYER.state != 'FALL' and PLAYER.state != 'JUMP'):
        PLAYER.jumph = 0
        PLAYER.state = 'JUMP'
    if(PLAYER.state == 'JUMP'):
        if(PLAYER.direction == 'RIGHT'):
            PLAYER.image = 'jump\\jumpr'
        elif (PLAYER.direction == 'LEFT'):
            PLAYER.image = 'jump\\jumpl'
        PLAYER.top -= spdx*1.5
        PLAYER.jumph += spdx*1.5
        if(keyboard.right):
            PLAYER.direction = 'RIGHT'
        elif(keyboard.left):
            PLAYER.direction = 'LEFT'
        if(PLAYER.jumph >= PLAYER.height + 2*floor[0].height):
            PLAYER.state = 'FALL'
        return
    if not PLAYER.floor:
        PLAYER.state = 'FALL'
    if(PLAYER.state == 'FALL'):
        if(PLAYER.direction == 'RIGHT'):
            PLAYER.image = 'landing\\landingr'
        elif (PLAYER.direction == 'LEFT'):
            PLAYER.image = 'landing\\landingl'
        PLAYER.top += spdx*1.5
        PLAYER.jumph -= spdx*1.5
        if(keyboard.right):
            PLAYER.direction = 'RIGHT'
        elif(keyboard.left):
            PLAYER.direction = 'LEFT'
        if collideFloor():
            PLAYER.state = 'IDLE'
        return
    ##MOVE RIGHT
    if(keyboard.right):
        if(PLAYER.state != 'RUN'):
            PLAYER.frame = 0
        PLAYER.state,PLAYER.direction = 'RUN','RIGHT'
        PLAYER.frame += 0.25
        PLAYER.image = runrset[int(PLAYER.frame)%8]
        PLAYER.moveRight(1)
        return
    ##MOVE LEFT
    elif(keyboard.left):
        if(PLAYER.state != 'RUN'):
            PLAYER.frame = 0
        PLAYER.state,PLAYER.direction = 'RUN','LEFT'
        PLAYER.frame += 0.25
        PLAYER.image = runlset[int(PLAYER.frame)%8]
        PLAYER.moveLeft(1)
        return
    if(PLAYER.state != 'IDLE'):
        PLAYER.frame = 0
    PLAYER.state = 'IDLE'
    ##IDLE
    if(PLAYER.state == 'IDLE' and PLAYER.direction == 'LEFT'):
        PLAYER.frame += 0.25
        PLAYER.image = idlelset[int(PLAYER.frame)%12]
    elif(PLAYER.state == 'IDLE' and PLAYER.direction == 'RIGHT'):
        PLAYER.frame += 0.25
        PLAYER.image = idlerset[int(PLAYER.frame)%12]




initializeMap()
pgzrun.go()
'''问题：1、下一关无法显示block，但是block的位置都对
         2、上一关的floor虽然不显示，但是还存在（可以踩、跳）
   TODO：1、定义collideblock函数，针对左右撞击  '''
