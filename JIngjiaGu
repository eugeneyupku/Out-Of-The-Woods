import pgzrun
import types
##Initialize
WIDTH,HEIGHT = 768,432
OUT = (-100,0)
TIME = 0
runlset,runrset,idlelset,idlerset = [],[],[],[] #List of actions' frames
bg = [] #Background
floor, door = [], [Actor('door')] #Floor
board, begin_pos, end_pos = [], [], [] #begin_pos是board初始时的左侧位置，end_pos是board终止时的左侧位置
star,starCount = [],[]
spdx = 3 #Speed of moves
starSum = 0
stage = 1
all_elements = floor + door
#======================IMPORT DEFAULT IMAGES======================
#Character
PLAYER = Actor('player\\idle\idler\idler0')
for i in range(8):
    runrset.append('player\\run\\runr\\right'+str(i))
    runlset.append('player\\run\\runl\\left'+str(i))
for i in range(12):
    idlerset.append('player\\idle\\idler\\idler'+str(i))
    idlelset.append('player\\idle\\idlel\\idlel'+str(i))
#Background
for i in range(5):
    bg.append(Actor("background\\plx-" + str(i+1)))

#======================DEFINE CLASS======================
class Floor(list):
    def collideFloor(self):
        for i in self:
            if (PLAYER.colliderect( \
                    i) and i.top - 4 * spdx <= PLAYER.bottom <= i.top + 4 * spdx and PLAYER.left >= i.left - 8 * spdx and PLAYER.right <= i.right + 8 * spdx):
                return True
        return False

    def collideLeft(self):
        for i in self:
            if (PLAYER.colliderect( \
                    i) and i.bottom - 4 * spdx <= PLAYER.bottom <= i.bottom + 4 * spdx and i.right - 4 * spdx <= PLAYER.left <= i.right + 4 * spdx):
                return True
        return False

    def collideRight(self):
        for i in self:
            if (PLAYER.colliderect( \
                    i) and i.bottom - 4 * spdx <= PLAYER.bottom <= i.bottom + 4 * spdx and i.left - 4 * spdx <= PLAYER.right <= i.left + 4 * spdx):
                return True
        return False
#======================INITIALIZE VARIABLES======================
def initializeVariable1():
    global floor,board
    floor = Floor()
    board = Floor()
    for i in range(2):
        floor.append(Actor('tileset\\ground'))
    #Star
    for i in range(3):
        star.append(Actor('star'))

def initializeVariable2():
    global floor,board
    floor = Floor()
    board = Floor()
    for i in range(10):
        floor.append(Actor('tileset\\block'))
    #Star
    for i in range(3):
        star.append(Actor('star'))

def initializeVariable3():
    global floor, board
    floor = Floor()
    board = Floor()
    for i in range(4):
        floor.append(Actor('tileset\\block'))
    for i in range(2):
        board.append(Actor('tileset\\board'))
    # Star
    for i in range(3):
        star.append(Actor('star'))



def initializeVariable():
    global PLAYER,starSum,starCount
    PLAYER.jumph = 0
    PLAYER.frame = 0
    PLAYER.state = 'IDLE'
    PLAYER.direction = 'RIGHT'
    starSum = 0
    #Countstar
    starCount = []
    for i in range(3):
        starCount.append(Actor('greystar'))
    if(stage == 1):
        return initializeVariable1()
    elif(stage == 2):
        return initializeVariable2()
    elif(stage == 3):
        return initializeVariable3()

#======================SETUP MAP======================
def clearMap():
    for i in all_elements:
        i.left = OUT

def initializeMap1():
    global PLAYER,floor,door,star
    #Background
    for i in range(5):
        bg[i].topleft = 0,0
    #Floor
    floor[0].bottomright = WIDTH * 0.5, HEIGHT - PLAYER.height - floor[0].height + 2
    floor[1].bottomleft = WIDTH * 0.5, HEIGHT - PLAYER.height - floor[0].height + 2
    #Door
    door[0].bottomright = floor[1].right, floor[1].top + 5
    #Player
    PLAYER.bottomleft = floor[0].topleft
    #Star
    for i in range(3):
        star[i].bottomleft = floor[0].left + PLAYER.width + (i + 1) * 60, floor[0].top - 10

def initializeMap2():
    global PLAYER,floor,door,star
    #Floor
    floor[0].midbottom = WIDTH * 0.5 - 26, HEIGHT - 30
    floor[1].midbottom = WIDTH * 0.5 + 26, HEIGHT - 30
    floor[2].bottomright = floor[0].topleft
    floor[3].bottomleft = floor[1].topright
    floor[4].bottomleft = floor[3].bottomright
    floor[5].bottomright = floor[2].topleft
    floor[6].bottomright = floor[3].topright
    floor[7].bottomright = floor[5].topright
    floor[8].bottomleft = floor[2].right, floor[7].bottom
    floor[9].bottomright = floor[6].topleft
    #Door
    door[0].bottomright = floor[4].topright
    #Player
    PLAYER.bottomleft = floor[0].topleft
    #Star
    star[0].midbottom = floor[1].midtop
    star[1].midbottom = floor[2].midtop
    star[2].midbottom = floor[9].midtop

def initializeMap3():
    global PLAYER, floor, board, door, star, begin_pos, end_pos
    #Floor
    floor[0].center = WIDTH * 0.5 - 3 * 52, HEIGHT * 0.5 + 3 * 52
    floor[1].center = WIDTH * 0.5 - 52, HEIGHT * 0.5 + 2 * 52
    floor[2].center = WIDTH * 0.5 + 52, HEIGHT * 0.5 + 2 * 52
    floor[3].center = WIDTH * 0.5 - 3 * 52, HEIGHT * 0.5
    #MovingBoard
    for i in range(2):
        board[i].midtop = WIDTH * 0.5 + (6 * i - 3) * 52, HEIGHT * 0.5 + (3.5 - 3 * i ) * 52
        begin_pos.append(board[i].left)
    end_pos = [WIDTH * 0.5 + 2.5 * 52, WIDTH * 0.5 - 4.5 * 52 ]
    #Door
    door[0].bottomleft = floor[3].topleft
    #PLAYER
    PLAYER.bottomleft = floor[0].topleft
    #Star
    star[0].center = WIDTH * 0.5 + 52, HEIGHT * 0.5 + 3*52
    star[1].center = WIDTH * 0.5 + 52, HEIGHT * 0.5 - 52
    star[2].center = WIDTH * 0.5 - 52, HEIGHT * 0.5 - 2 * 52





def initializeMap():
    global bg,starCount
    #Background
    for i in range(5):
        bg[i].topleft = 0, 0
    #Countstar
    for i in range(3):
        starCount[i].midtop = WIDTH * 0.5 + (i - 1) * 50, 30
    if(stage == 1):
        initializeMap1()
    elif(stage == 2):
        initializeMap2()
    elif(stage == 3):
        initializeMap3()

#======================RESTART THE GAME======================
def StageRestart():
    clearMap()
    initializeVariable()
    initializeMap()

#======================DRAW STAGE======================
def drawStage1():
    for i in floor:
        i.draw()
    for i in door:
        i.draw()

def drawStage2():
    for i in floor:
        i.draw()
    for i in door:
        i.draw()

def drawStage3():
    for i in floor:
        i.draw()
    for i in board:
        i.draw()
    for i in door:
        i.draw()


def drawStage():
    for i in bg:
        i.draw()
    for i in starCount:
        i.draw()
    for i in star:
        i.draw()
    if stage == 1:
        drawStage1()
    elif stage == 2:
        drawStage2()
    elif stage == 3:
        drawStage3()
    PLAYER.draw()
#======================ACTOR MOVEMENT======================
def moveLeft(act,mode=0): ##Mode 0: Infinite Move(Loop); Mode 1: Bordered Move
    if(mode == 1 and act.left <= 0):
        return
    act.left -= spdx
    if(mode == 0 and act.right < 0):
        act.left = WIDTH-spdx

def moveRight(act,mode=0):
    if(mode == 1 and act.right >= WIDTH):
        return
    act.left += spdx
    if(mode == 0 and act.left > WIDTH):
        act.right = spdx




#======================INTERACTION======================

def back(act, begin_pos):
    act.left = begin_pos

def moving_left(act):
    act.left -= 0.7 * spdx

def moving_right(act):
    act.left += 0.7 * spdx

def towards_left(begin_pos, end_pos):
    if end_pos < begin_pos:
        return True
    else:
        return False


#================================SET ATTRIBUTE====================================
PLAYER.__setattr__('moveRight',types.MethodType(moveRight,PLAYER))
PLAYER.__setattr__('moveLeft',types.MethodType(moveLeft,PLAYER))

#================================VICTORY OR DEFEAT================================
def playerlose():
    global PLAYER, starSum
    if starSum < 3 and PLAYER.collidepoint(door[0].center):
        return True
    elif PLAYER.top >= HEIGHT:
        return True
    return False

def playerwin():
    global PLAYER, starSum
    if starSum == 3 and PLAYER.collidepoint(door[0].center):
        return True
    else:
        return False

#================================DRAW & UPDATE====================================
def draw():
    screen.clear()
    drawStage()



def update():
    global PLAYER, starSum, stage, begin_pos, end_pos
    PLAYER.floor = (floor.collideFloor() or board.collideFloor())
    if PLAYER.state == 'DEAD' or PLAYER.state == 'WIN':
        return
    ##Win or Lose
    if playerlose():
        PLAYER.state = 'DEAD'
        return clock.schedule_unique(StageRestart, 1)
    if playerwin():
        stage += 1
        PLAYER.state = 'WIN'
        return clock.schedule_unique(StageRestart, 1)
    ##Pick Star
    for i in star:
        if PLAYER.colliderect(i):
            star.remove(i)
            starCount[starSum].image = 'brightstar'
            starSum += 1
    ##MovingBoard
    if board != []:
        for i in range(len(board)):
            if towards_left(begin_pos[i], end_pos[i]):
                moving_left(board[i])
                if board[i].left <= end_pos[i]:
                    # PLAYER.state = 'FALL'
                    back(board[i], begin_pos[i])
            else:
                moving_right(board[i])
                if board[i].left >= end_pos[i]:
                    back(board[i], begin_pos[i])

    ##JUMP
    if(keyboard.up and PLAYER.state != 'FALL' and PLAYER.state != 'JUMP'):
        PLAYER.jumph = 0
        PLAYER.state = 'JUMP'
    if(PLAYER.state == 'JUMP'):
        if(PLAYER.direction == 'RIGHT'):
            PLAYER.image = 'player\\jump\\jumpr'
        elif (PLAYER.direction == 'LEFT'):
            PLAYER.image = 'player\\jump\\jumpl'
        PLAYER.top -= spdx*1.5
        PLAYER.jumph += spdx*1.5
        if(keyboard.right):
            PLAYER.direction = 'RIGHT'
        elif(keyboard.left):
            PLAYER.direction = 'LEFT'
        if(PLAYER.jumph >= PLAYER.height + 2*floor[0].height):
            PLAYER.state = 'FALL'
        return
    if not PLAYER.floor:
        PLAYER.state = 'FALL'
    if(PLAYER.state == 'FALL'):
        if(PLAYER.direction == 'RIGHT'):
            PLAYER.image = 'player\\landing\\landingr'
        elif (PLAYER.direction == 'LEFT'):
            PLAYER.image = 'player\\landing\\landingl'
        PLAYER.top += spdx*1.5
        PLAYER.jumph -= spdx*1.5
        if(keyboard.right):
            PLAYER.direction = 'RIGHT'
        elif(keyboard.left):
            PLAYER.direction = 'LEFT'
        if PLAYER.floor:
            PLAYER.state = 'IDLE'
        return
    ##MOVE RIGHT
    if(keyboard.right and not floor.collideRight()):
        if(PLAYER.state != 'RUN'):
            PLAYER.frame = 0
        PLAYER.state,PLAYER.direction = 'RUN','RIGHT'
        PLAYER.frame += 0.25
        PLAYER.image = runrset[int(PLAYER.frame)%8]
        PLAYER.moveRight(1)
        return
    ##MOVE LEFT
    elif(keyboard.left and not floor.collideLeft()):
        if(PLAYER.state != 'RUN'):
            PLAYER.frame = 0
        PLAYER.state,PLAYER.direction = 'RUN','LEFT'
        PLAYER.frame += 0.25
        PLAYER.image = runlset[int(PLAYER.frame)%8]
        PLAYER.moveLeft(1)
        return
    if(PLAYER.state != 'IDLE'):
        PLAYER.frame = 0
    PLAYER.state = 'IDLE'
    ##IDLE
    if(PLAYER.state == 'IDLE' and PLAYER.direction == 'LEFT'):
        PLAYER.frame += 0.25
        PLAYER.image = idlelset[int(PLAYER.frame)%12]
    elif(PLAYER.state == 'IDLE' and PLAYER.direction == 'RIGHT'):
        PLAYER.frame += 0.25
        PLAYER.image = idlerset[int(PLAYER.frame)%12]








StageRestart()
pgzrun.go()
