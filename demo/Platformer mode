import pgzrun
import types
##Initialize
WIDTH,HEIGHT = 768,432
OUT = (-100,0)
TIME = 0
runlset,runrset,idlelset,idlerset = [],[],[],[] #List of actions' frames
mobswalkr,mobswalkl = [],[]
bg1,bg2 = [],[] #Background
ground,block,layer1 = [],[],[] #Ground and layer1
door = []
killTrap,fallTrap = [],[]
mobs1,mobs2 = [],[]
spdx = 3 #Speed of moves

#Merge Lists
floor = ground + block + layer1
trap = killTrap + fallTrap
tiles = trap + floor + door
bg = bg1 + bg2
mobs = mobs1 + mobs2
blocks = tiles + mobs

#======================IMPORT IMAGE======================
#Character
for i in range(8):
    runrset.append('run\\runr\\right'+str(i))
    runlset.append('run\\runl\\left'+str(i))
for i in range(12):
    idlerset.append('idle\\idler\\idler'+str(i))
    idlelset.append('idle\\idlel\\idlel'+str(i))
#Mobs
for i in range(6):
    mobswalkl.append('mobs\\walkl\\walkl' + str(i))
    mobswalkr.append('mobs\\walkr\\walkr' + str(i))

#======================SETUP CHARACTER======================
PLAYER = Actor('idle\idler\idler0')

#======================CAMERA======================
rightLimit,leftLimit = 50*81-WIDTH/2,WIDTH/2 
rightBorder,leftBorder = 50*81-PLAYER.width,PLAYER.width
camCenter = leftBorder

#======================INITIALIZE VARIABLES======================
def initializeVariable():
    global PLAYER,MaxJumpHeight,bg1,bg2,ground,block,layer1,door,killTrap,fallTrap,mobs1,mobs2,rightlimit,leftLimit,rightBorder,leftBorder,camCenter
    bg1,bg2,ground,block,layer1,door,killTrap,fallTrap,mobs1,mobs2 = [],[],[],[],[],[],[],[],[],[]
    #Background
    for i in range(5):
        bg1.append(Actor("background\\plx-" + str(i+1)))
        bg2.append(Actor("background\\plx-" + str(i+1)))
    #Floor
    for i in range(50):
        ground.append(Actor('tileset\\ground'))
    for i in range(9):
        block.append(Actor('tileset\\block'))
    for i in range(10):
        layer1.append(Actor('tileset\\ground'))
    for i in range(1):
        door.append(Actor('door'))
    ##Trap
    #Kill Trap
    for i in range(6):
        tmp = Actor('spike')
        tmp.effect = 'DEAD'
        killTrap.append(tmp)
    #Fall Trap
    for i in range(2):
        fallTrap.append(Actor('tileset\\ground'))  
        fallTrap[i].fall = False
    #Setup Mobs
    for i in range(1):
        mobs1.append(Actor('mobs\\walkr\\walkr0'))
        mobs1[i].range = ground[0].width-mobs1[i].width/2
        mobs1[i].state = 'WALK'
        mobs1[i].direction = 'RIGHT'
        mobs1[i].frame = 0
        mobs1[i].jumph = 0
        mobs1[i].camCenter = 0
    for i in range(1):
        mobs2.append(Actor('mobs\\walkr\\walkr0'))
        mobs2[i].range = ground[0].width-mobs2[i].width/2
        mobs2[i].state = 'WALK'
        mobs2[i].direction = 'RIGHT'
        mobs2[i].frame = 0
        mobs2[i].jumph = 0
        mobs2[i].camCenter = 0
    #Player
    PLAYER.jumph = 0
    PLAYER.frame = 0
    PLAYER.state = 'FALL'
    PLAYER.direction = 'RIGHT'
    #Camera
    rightLimit,leftLimit = 50*81-WIDTH/2,WIDTH/2 
    rightBorder,leftBorder = 50*81-PLAYER.width,PLAYER.width
    camCenter = leftBorder
    MaxJumpHeight = PLAYER.height + 2*ground[0].height

def mergeList():
    global floor,trap,tiles,bg,blocks,mobs
    floor = ground + block + layer1
    trap = killTrap + fallTrap
    tiles = trap + floor + door
    bg = bg1 + bg2
    mobs= mobs1 + mobs2
    blocks = tiles + mobs

#======================SETUP MAP======================
def initializeMap():
    gap = ground[0].width - 2
    layer1H = HEIGHT - PLAYER.height - ground[0].height + 2
    #Player
    PLAYER.topleft = 0,0
    #Background
    for i in range(5):
        bg1[i].topright = WIDTH*0.5,0
        bg2[i].topleft = WIDTH*0.5,0
    ##Trap
    #KillTrap
    killTrap[0].bottomleft = 0,HEIGHT-2
    killTrap[1].bottomleft = gap,HEIGHT-2
    killTrap[2].bottomright = 3*gap,HEIGHT-2
    killTrap[3].bottomleft = 12*gap,layer1H
    killTrap[4].bottomleft = 12*gap+killTrap[0].width,layer1H-2
    killTrap[5].bottomleft = 24*gap,layer1H-2
    #FallTrap
    fallTrap[0].bottomleft = 9*gap,HEIGHT
    fallTrap[1].bottomleft = 9*gap,layer1H
    #Floor
    for i in range(50):
        ground[i].bottomleft = i*(gap),HEIGHT
    for i in range(3,50,3):
        if(i == 12 or i == 15 or i == 18 or i == 21 or i == 24):
            continue
        ground[i].bottomleft = OUT
    #Block
    block[0].bottomleft = 15*gap,HEIGHT-ground[0].height
    block[1].bottomleft = block[0].bottomright
    block[2].bottomleft = block[1].bottomright
    block[3].bottomleft = 18*gap,HEIGHT-ground[0].height
    block[4].bottomleft = block[3].bottomright
    block[5].bottomleft = block[4].bottomright
    block[6].bottomleft = 21*gap,HEIGHT-ground[0].height
    block[7].bottomleft = block[6].bottomright
    block[8].bottomleft = block[7].bottomright

    #ground_half[0].bottomleft = 4*(ground[0].width-5),HEIGHT    
    for i in range(10):
        layer1[i].bottomleft = 3*(i+1)*(gap),layer1H
    layer1[2].bottomleft = OUT
    layer1[4].bottomleft = OUT
    layer1[5].bottomleft = OUT
    layer1[6].bottomleft = OUT
    #Mobs
    mobs[0].bottomleft = 17*gap-mobs[0].width/2,HEIGHT - ground[0].height
    mobs[1].bottomleft = 20*gap-mobs[0].width/2,HEIGHT - ground[0].height
    #Door
    door[0].bottomright = layer1[7].topright

#======================RESTART STAGE======================
def restartStage():
    initializeVariable()
    mergeList()
    initializeMap()

#======================ACTOR MOVEMENT======================
#Infinite Moves
def moveLeft(act,mode=0): ##Mode 0: Infinite Move; Mode 1: Bordered Move
    if(mode == 1 and act.left <= 0):
        return
    act.left -= spdx
    if(mode == 0 and act.right < 0):
        act.left = WIDTH-spdx

def moveRight(act,mode=0):
    if(mode == 1 and act.right >= WIDTH):
        return
    act.left += spdx
    if(mode == 0 and act.left > WIDTH):
        act.right = spdx

#======================SET ATTRIBUTE======================
PLAYER.__setattr__('moveRight',types.MethodType(moveRight,PLAYER))
PLAYER.__setattr__('moveLeft',types.MethodType(moveLeft,PLAYER))

#======================MOVE IN GROUP======================
#Background
def bgLeft():
    for i in bg:
        moveLeft(i)
def bgRight():
    for i in bg:
        moveRight(i)
#Floor
def blocksLeft():
    for i in blocks:
        i.left -= spdx
def blocksRight():
    for i in blocks:
        i.left += spdx

#Screen
def screenLeft():
    global camCenter
    camCenter += spdx
    if(camCenter > rightBorder):
        camCenter = rightBorder
    if(rightLimit <= camCenter):
        PLAYER.moveRight(1)
    elif(camCenter <= leftLimit):
        PLAYER.moveRight(1)
    else:
        bgLeft()
        blocksLeft()
def screenRight():
    global camCenter
    camCenter -= spdx
    if(camCenter < leftBorder):
        camCenter = leftBorder
    if(camCenter <= leftLimit):
        PLAYER.moveLeft(1)
    elif(rightLimit <= camCenter):
        PLAYER.moveLeft(1)
    else:
        bgRight()
        blocksRight()
#Mobs:
def mobsMove(act):
    act.frame += 0.25
    if(act.direction == 'RIGHT'):
        act.left += spdx/2
        act.camCenter += spdx/2
        act.image = mobswalkr[int(act.frame%6)]
    else:
        act.camCenter -= spdx/2
        act.left -= spdx/2
        act.image = mobswalkl[int(act.frame%6)]
def mobsJump(act):
    if(act.jumph <= MaxJumpHeight):
        act.top -= 1.5*spdx
        act.jumph += 1.5*spdx
    else:
        act.state = 'FALL'

def mobsFall(act):
    act.top += 1.5*spdx
    act.jumph -= 1.5*spdx
        
#======================Interaction======================
#COLLISION
def collideFloor(act=PLAYER):
    for i in floor:
        if(act.colliderect(i) and i.top-4*spdx<= act.bottom <= i.top+4*spdx):
            return True
    return False

def collideLeft():
    for i in floor:
        if(PLAYER.colliderect(i) and i.bottom-4*spdx <= PLAYER.bottom <= i.bottom+4*spdx and i.right-4*spdx <= PLAYER.left <= i.right+4*spdx):
            return True
    return False

def collideRight():
    for i in floor:
        if(PLAYER.colliderect(i) and i.bottom-4*spdx <= PLAYER.bottom <= i.bottom+4*spdx and i.left-4*spdx <= PLAYER.right <= i.left+4*spdx):
            return True
    return False
#======================VICTORY AND DEFEAT======================
def playerLose():
    global PLAYER
    PLAYER.status = 'DEAD'
    for i in killTrap:
        if(PLAYER.colliderect(i) and i.effect == 'DEAD'):
            i.top -= 30
            return True
    for i in mobs:
        if(PLAYER.colliderect(i)):
            return True
    if(PLAYER.top >= HEIGHT):
        return True
    return False

def playerWin():
    for i in door:
        if(PLAYER.colliderect(i)):
            return True
    return False

#======================DRAW STAGE======================
def drawStage1():
    for i in bg:
        i.draw()
    for i in trap:
        i.draw()    
    for i in tiles:
        i.draw()
    for i in mobs:
        i.draw()
#======================DRAW & UPDATE======================
def draw():
    drawStage1()
    PLAYER.draw()

def update():
    global PLAYER,mobs
    if(PLAYER.state == 'DEAD' or PLAYER.state == 'WIN'):
        return
    ##Interactions
    if(playerLose()):
        PLAYER.state = 'DEAD'
        clock.schedule(restartStage,0.25)
        return
    if(playerWin()):
        PLAYER.state = 'WIN'
        clock.schedule(restartStage,0.25)
        return
    #MobsMove
    for i in mobs:
        if(i.camCenter <= -i.range):
            i.direction = 'RIGHT'
        elif(i.camCenter >= i.range):
            i.direction = 'LEFT'
        if(i.state == 'FALL' and collideFloor()):
            i.state = 'WALK'
        if(i.state == 'JUMP'):
            mobsJump(i)
        if(i.state != 'JUMP' and not collideFloor(i)):
            i.state = 'FALL'
            mobsFall(i)
        mobsMove(i)
    #fallTrap
    for i in fallTrap:
        if(i.fall):
            i.top += 5
        if(PLAYER.colliderect(i) and i.top-4*spdx<= PLAYER.bottom <= i.top+4*spdx):
            i.top += 5
            i.fall = True
    #On Floor
    PLAYER.floor = collideFloor()
    ##JUMP
    if(keyboard.up and PLAYER.state != 'FALL' and PLAYER.state != 'JUMP'):
        PLAYER.jumph = 0
        PLAYER.state = 'JUMP'
    if(PLAYER.state == 'JUMP'):
        if(PLAYER.direction == 'RIGHT'):
            PLAYER.image = 'jump\\jumpr'
        elif (PLAYER.direction == 'LEFT'):
            PLAYER.image = 'jump\\jumpl'
        PLAYER.top -= spdx*1.5
        if(mobs[1].state != 'FALL'):
            mobs[1].state = 'JUMP'
        PLAYER.jumph += spdx*1.5
        if(keyboard.right and not collideRight()):
            PLAYER.direction = 'RIGHT'
            screenLeft()
        elif(keyboard.left and not collideLeft()):
            PLAYER.direction = 'LEFT'
            screenRight()
        if(PLAYER.jumph >= PLAYER.height + 2*ground[0].height):
            PLAYER.state = 'FALL'
        return
    if not PLAYER.floor:
        PLAYER.state = 'FALL'
    if(PLAYER.state == 'FALL'):
        if(PLAYER.direction == 'RIGHT'):
            PLAYER.image = 'landing\\landingr'
        elif (PLAYER.direction == 'LEFT'):
            PLAYER.image = 'landing\\landingl'
        PLAYER.top += spdx*1.5
        PLAYER.jumph -= spdx*1.5
        if(keyboard.right):
            PLAYER.direction = 'RIGHT'
            screenLeft()
        elif(keyboard.left):
            PLAYER.direction = 'LEFT'
            screenRight()
        if collideFloor():
            PLAYER.state = 'IDLE'
        return
    ##MOVE RIGHT    
    if(keyboard.right and not collideRight()):
        if(PLAYER.state != 'RUN'):
            PLAYER.frame = 0
        PLAYER.state,PLAYER.direction = 'RUN','RIGHT'
        PLAYER.frame += 0.25
        PLAYER.image = runrset[int(PLAYER.frame)%8]
        screenLeft()
        return
    ##MOVE LEFT
    elif(keyboard.left and not collideLeft()): 
        if(PLAYER.state != 'RUN'):
            PLAYER.frame = 0
        PLAYER.state,PLAYER.direction = 'RUN','LEFT'
        PLAYER.frame += 0.25
        PLAYER.image = runlset[int(PLAYER.frame)%8]
        screenRight()
        return
    if(PLAYER.state != 'IDLE'):
        PLAYER.frame = 0
    PLAYER.state = 'IDLE'
    ##IDLE
    if(PLAYER.state == 'IDLE' and PLAYER.direction == 'LEFT'): 
        PLAYER.frame += 0.25
        PLAYER.image = idlelset[int(PLAYER.frame)%12]
    elif(PLAYER.state == 'IDLE' and PLAYER.direction == 'RIGHT'):
        PLAYER.frame += 0.25
        PLAYER.image = idlerset[int(PLAYER.frame)%12]

restartStage()
pgzrun.go()
